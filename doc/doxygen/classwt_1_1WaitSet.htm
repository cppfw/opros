<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libwait: wt::WaitSet Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libwait
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.htm"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.htm"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.htm"><span>Classes</span></a></li>
      <li><a href="files.htm"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.htm"><span>Class&#160;List</span></a></li>
      <li><a href="classes.htm"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.htm"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.htm"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classwt_1_1WaitSet.htm','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classwt_1_1WaitSet-members.htm">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">wt::WaitSet Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set of <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> objects to wait for.  
 <a href="classwt_1_1WaitSet.htm#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="WaitSet_8hpp_source.htm">WaitSet.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet_1_1Exc.htm">Exc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a> related exception class.  <a href="classwt_1_1WaitSet_1_1Exc.htm#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad195a9d2419261846e2d564ab8f9a06f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#ad195a9d2419261846e2d564ab8f9a06f">WaitSet</a> (unsigned maxSize)</td></tr>
<tr class="memdesc:ad195a9d2419261846e2d564ab8f9a06f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="#ad195a9d2419261846e2d564ab8f9a06f">More...</a><br/></td></tr>
<tr class="separator:ad195a9d2419261846e2d564ab8f9a06f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802cff0067d921e1dc4c52df2a2d9722"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a802cff0067d921e1dc4c52df2a2d9722">~WaitSet</a> () noexcept</td></tr>
<tr class="memdesc:a802cff0067d921e1dc4c52df2a2d9722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a802cff0067d921e1dc4c52df2a2d9722">More...</a><br/></td></tr>
<tr class="separator:a802cff0067d921e1dc4c52df2a2d9722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28fe693d3a07ae3f806aab2e0af9698a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a28fe693d3a07ae3f806aab2e0af9698a">size</a> () const noexcept</td></tr>
<tr class="memdesc:a28fe693d3a07ae3f806aab2e0af9698a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get maximum size of the wait set.  <a href="#a28fe693d3a07ae3f806aab2e0af9698a">More...</a><br/></td></tr>
<tr class="separator:a28fe693d3a07ae3f806aab2e0af9698a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce384253176742d278e832e1bfb0293"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a3ce384253176742d278e832e1bfb0293">numWaitables</a> () const noexcept</td></tr>
<tr class="memdesc:a3ce384253176742d278e832e1bfb0293"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of Waitables already added to this <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a>.  <a href="#a3ce384253176742d278e832e1bfb0293">More...</a><br/></td></tr>
<tr class="separator:a3ce384253176742d278e832e1bfb0293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99fb05b731fabf945ef36fe2c4d34573"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a99fb05b731fabf945ef36fe2c4d34573">add</a> (<a class="el" href="classwt_1_1Waitable.htm">Waitable</a> &amp;w, <a class="el" href="classwt_1_1Waitable.htm#ab819c1b64bf5c829ba979459f02404dc">Waitable::EReadinessFlags</a> flagsToWaitFor)</td></tr>
<tr class="memdesc:a99fb05b731fabf945ef36fe2c4d34573"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> object to the wait set.  <a href="#a99fb05b731fabf945ef36fe2c4d34573">More...</a><br/></td></tr>
<tr class="separator:a99fb05b731fabf945ef36fe2c4d34573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a04e0344ab4c2cac3daad4ad33fa1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a92a04e0344ab4c2cac3daad4ad33fa1b">change</a> (<a class="el" href="classwt_1_1Waitable.htm">Waitable</a> &amp;w, <a class="el" href="classwt_1_1Waitable.htm#ab819c1b64bf5c829ba979459f02404dc">Waitable::EReadinessFlags</a> flagsToWaitFor)</td></tr>
<tr class="memdesc:a92a04e0344ab4c2cac3daad4ad33fa1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change wait flags for a given <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a>.  <a href="#a92a04e0344ab4c2cac3daad4ad33fa1b">More...</a><br/></td></tr>
<tr class="separator:a92a04e0344ab4c2cac3daad4ad33fa1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11650e550e7f8bb812f29a32e29b8f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a11650e550e7f8bb812f29a32e29b8f97">remove</a> (<a class="el" href="classwt_1_1Waitable.htm">Waitable</a> &amp;w) noexcept</td></tr>
<tr class="memdesc:a11650e550e7f8bb812f29a32e29b8f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> from wait set.  <a href="#a11650e550e7f8bb812f29a32e29b8f97">More...</a><br/></td></tr>
<tr class="separator:a11650e550e7f8bb812f29a32e29b8f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14a5010ae4a3ce67658ce9867ac4fdf5"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a14a5010ae4a3ce67658ce9867ac4fdf5">wait</a> (utki::Buf&lt; <a class="el" href="classwt_1_1Waitable.htm">Waitable</a> * &gt; out_events)</td></tr>
<tr class="memdesc:a14a5010ae4a3ce67658ce9867ac4fdf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait for event.  <a href="#a14a5010ae4a3ce67658ce9867ac4fdf5">More...</a><br/></td></tr>
<tr class="separator:a14a5010ae4a3ce67658ce9867ac4fdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a202b28a7b05891015e65ab82b0eeeb72"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a202b28a7b05891015e65ab82b0eeeb72">wait</a> ()</td></tr>
<tr class="memdesc:a202b28a7b05891015e65ab82b0eeeb72"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait for event.  <a href="#a202b28a7b05891015e65ab82b0eeeb72">More...</a><br/></td></tr>
<tr class="separator:a202b28a7b05891015e65ab82b0eeeb72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b5ee1d07b427ca7c5627abc6ec3df6"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a11b5ee1d07b427ca7c5627abc6ec3df6">waitWithTimeout</a> (std::uint32_t timeout, utki::Buf&lt; <a class="el" href="classwt_1_1Waitable.htm">Waitable</a> * &gt; out_events)</td></tr>
<tr class="memdesc:a11b5ee1d07b427ca7c5627abc6ec3df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait for event with timeout.  <a href="#a11b5ee1d07b427ca7c5627abc6ec3df6">More...</a><br/></td></tr>
<tr class="separator:a11b5ee1d07b427ca7c5627abc6ec3df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bbc42e42896a471c7b318345993044"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classwt_1_1WaitSet.htm#a04bbc42e42896a471c7b318345993044">waitWithTimeout</a> (std::uint32_t timeout)</td></tr>
<tr class="memdesc:a04bbc42e42896a471c7b318345993044"><td class="mdescLeft">&#160;</td><td class="mdescRight">wait for event with timeout.  <a href="#a04bbc42e42896a471c7b318345993044">More...</a><br/></td></tr>
<tr class="separator:a04bbc42e42896a471c7b318345993044"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set of <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> objects to wait for. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad195a9d2419261846e2d564ab8f9a06f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wt::WaitSet::WaitSet </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSize</td><td>- maximum number of <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> objects can be added to this wait set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a802cff0067d921e1dc4c52df2a2d9722"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">wt::WaitSet::~WaitSet </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>
<p>Note, that destructor will check if the wait set is empty. If it is not, then an assert will be triggered. It is user's responsibility to remove any waitable objects from the waitset before the wait set object is destroyed. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a99fb05b731fabf945ef36fe2c4d34573"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wt::WaitSet::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwt_1_1Waitable.htm">Waitable</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwt_1_1Waitable.htm#ab819c1b64bf5c829ba979459f02404dc">Waitable::EReadinessFlags</a>&#160;</td>
          <td class="paramname"><em>flagsToWaitFor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> object to the wait set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>- <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> object to add to the <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a>. </td></tr>
    <tr><td class="paramname">flagsToWaitFor</td><td>- determine events waiting for which we are interested. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ting::WaitSet::Exc</td><td>- in case the wait set is full or other error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a92a04e0344ab4c2cac3daad4ad33fa1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void wt::WaitSet::change </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwt_1_1Waitable.htm">Waitable</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classwt_1_1Waitable.htm#ab819c1b64bf5c829ba979459f02404dc">Waitable::EReadinessFlags</a>&#160;</td>
          <td class="paramname"><em>flagsToWaitFor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change wait flags for a given <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a>. </p>
<p>Changes wait flags for a given waitable, which is in this <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>- <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> for which the changing of wait flags is needed. </td></tr>
    <tr><td class="paramname">flagsToWaitFor</td><td>- new wait flags to be set for the given <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ting::WaitSet::Exc</td><td>- in case the given <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> object is not added to this wait set or other error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ce384253176742d278e832e1bfb0293"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wt::WaitSet::numWaitables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of Waitables already added to this <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>number of Waitables added to this <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a11650e550e7f8bb812f29a32e29b8f97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void wt::WaitSet::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classwt_1_1Waitable.htm">Waitable</a> &amp;&#160;</td>
          <td class="paramname"><em>w</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> from wait set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">w</td><td>- <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> object to be removed from the <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ting::WaitSet::Exc</td><td>- in case the given <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> is not added to this wait set or other error occurs. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a28fe693d3a07ae3f806aab2e0af9698a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wt::WaitSet::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get maximum size of the wait set. </p>
<dl class="section return"><dt>Returns</dt><dd>maximum number of Waitables this <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a> can hold. </dd></dl>

</div>
</div>
<a class="anchor" id="a14a5010ae4a3ce67658ce9867ac4fdf5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wt::WaitSet::wait </td>
          <td>(</td>
          <td class="paramtype">utki::Buf&lt; <a class="el" href="classwt_1_1Waitable.htm">Waitable</a> * &gt;&#160;</td>
          <td class="paramname"><em>out_events</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait for event. </p>
<p>This function blocks calling thread execution until one of the <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> objects in the <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a> triggers. Upon return from the function, pointers to triggered objects are placed in the 'out_events' buffer and the return value from the function indicates number of these objects which have triggered. Note, that it does not change the readiness state of non-triggered objects. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_events</td><td>- pointer to buffer where to put pointers to triggered <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> objects. The buffer will not be initialized to 0's by this function. The buffer shall be large enough to hold maxmimum number of Waitables this <a class="el" href="classwt_1_1WaitSet.htm" title="Set of Waitable objects to wait for. ">WaitSet</a> can hold. It is valid to pass 0 pointer, in that case this argument will not be used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects triggered. NOTE: for some reason, on Windows it can return 0 objects triggered. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ting::WaitSet::Exc</td><td>- in case of errors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a202b28a7b05891015e65ab82b0eeeb72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wt::WaitSet::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait for event. </p>
<p>Same as Wait(const Buffer&lt;Waitable*&gt;&amp; out_events) but does not return out_events. </p>
<dl class="section return"><dt>Returns</dt><dd>number of objects triggered. </dd></dl>

</div>
</div>
<a class="anchor" id="a11b5ee1d07b427ca7c5627abc6ec3df6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wt::WaitSet::waitWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">utki::Buf&lt; <a class="el" href="classwt_1_1Waitable.htm">Waitable</a> * &gt;&#160;</td>
          <td class="paramname"><em>out_events</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait for event with timeout. </p>
<p>The same as Wait() function, but takes wait timeout as parameter. Thus, this function will wait for any event or timeout. Note, that it guarantees that it will wait AT LEAST for specified number of milliseconds, or more. This is because of implementation for linux, if wait is interrupted by signal it will start waiting again, and so on. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>- maximum time in milliseconds to wait for event. </td></tr>
    <tr><td class="paramname">out_events</td><td>- buffer where to put pointers to triggered <a class="el" href="classwt_1_1Waitable.htm" title="Base class for objects which can be waited for. ">Waitable</a> objects. The buffer size must be equal or greater than the number of waitables currently added to the wait set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects triggered. If 0 then timeout was hit. NOTE: for some reason, on Windows it can return 0 before timeout was hit. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">ting::WaitSet::Exc</td><td>- in case of errors. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a04bbc42e42896a471c7b318345993044"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned wt::WaitSet::waitWithTimeout </td>
          <td>(</td>
          <td class="paramtype">std::uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>wait for event with timeout. </p>
<p>Same as WaitWithTimeout(std::uint32_t timeout, const Buffer&lt;Waitable*&gt;&amp; out_events) but does not return out_events. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timeout</td><td>- maximum time in milliseconds to wait for event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of objects triggered. If 0 then timeout was hit. NOTE: for some reason, on Windows it can return 0 before timeout was hit. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="WaitSet_8hpp_source.htm">WaitSet.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacewt.htm">wt</a></li><li class="navelem"><a class="el" href="classwt_1_1WaitSet.htm">WaitSet</a></li>
    <li class="footer">Generated on Mon Sep 28 2015 01:12:06 for libwait by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
